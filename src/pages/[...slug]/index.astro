---
/**
 * Dynamic page template for categories and subcategories
 * Implements the warm, minimal design system with:
 * - Hero section with featured image
 * - Breadcrumb navigation
 * - Body content with internal linking
 * - Key takeaways section
 * - Child categories card grid (3-col responsive)
 * - Related categories section
 */

import BaseLayout from '../../layouts/BaseLayout.astro';
import HeroImage from '../../components/HeroImage.astro';
import ContentRenderer from '../../components/ContentRenderer.astro';
import CategoryCard from '../../components/CategoryCard.astro';
import BreadcrumbSchema from '../../components/schemas/BreadcrumbSchema.astro';
import WebPageSchema from '../../components/schemas/WebPageSchema.astro';
import FAQPageSchema from '../../components/schemas/FAQPageSchema.astro';
import HowToSchema from '../../components/schemas/HowToSchema.astro';
import SoftwareApplicationSchema from '../../components/schemas/SoftwareApplicationSchema.astro';
import AggregateRatingSchema from '../../components/schemas/AggregateRatingSchema.astro';
import { DB, type Category, type Subcategory } from '../../utils/db';
import type { PageContext } from '../../utils/internalLinking/targetResolver';
import { resolveOgImage, resolveHeroImage, withAbsoluteUrl, loadImageById } from '../../utils/images';
import type { ContentItem } from '../../utils/videos/types';
import type { ImageWithUrl } from '../../utils/images/types';
import {
  getAvailableLocalesForEntity,
  getLocalizedField,
  buildLocalizedUrl,
  buildHreflangLinks,
  getLocalizedContentSection
} from '../../utils/i18n';
import { getLocalizedRichResults } from '../../utils/schemas';

// Generate all static paths from relational database
export function getStaticPaths() {
  const isPublished = (entity: Category | Subcategory): boolean => {
    return !entity.status || entity.status === 'published';
  };

  const paths = [];

  // Add all category pages (with locale variants)
  for (const category of DB.getAllCategories()) {
    if (!isPublished(category)) continue;

    const availableLocales = getAvailableLocalesForEntity(category);

    for (const locale of availableLocales) {
      paths.push({
        params: { slug: `${locale}/${category.slug}` },
        props: {
          type: 'category' as const,
          data: category,
          locale
        }
      });
    }
  }

  // Add all subcategory pages (with locale variants)
  for (const subcategory of DB.getAllSubcategories()) {
    if (!isPublished(subcategory)) continue;

    const availableLocales = getAvailableLocalesForEntity(subcategory);
    const fullPath = DB.getFullPath(subcategory);

    for (const locale of availableLocales) {
      paths.push({
        params: { slug: `${locale}/${fullPath}` },
        props: {
          type: 'subcategory' as const,
          data: subcategory,
          locale
        }
      });
    }
  }

  return paths;
}

const { type, data, locale } = Astro.props;
const rawBase = import.meta.env.BASE_URL;
const base = rawBase.endsWith('/') ? rawBase.slice(0, -1) : rawBase;
const siteBase = Astro.site?.toString().replace(/\/$/, '') || 'https://prseoastro.pages.dev';

// Get available locales and build alternate URLs
const availableLocales = getAvailableLocalesForEntity(data);
const hreflangLinks = buildHreflangLinks(data, siteBase, base);

// Build alternate URLs for language switcher
const alternateUrls = availableLocales.map(loc => ({
  locale: loc,
  url: buildLocalizedUrl(loc, data, base)
}));

// Get localized fields
const title = getLocalizedField<string>(data, 'title', locale) || data.id;
const description = getLocalizedField<string>(data, 'description', locale) || '';

// Build page-specific data based on type
interface ChildItem {
  title: string;
  description: string;
  url: string;
  image: ImageWithUrl | null;
}

let breadcrumbs: Array<{ title: string; url: string }>;
let childItems: ChildItem[] = [];
let relatedItems: ChildItem[] = [];
let parentCategory: Category | undefined;

if (type === 'category') {
  const category = data as Category;
  breadcrumbs = [{ title, url: `/${locale}/${category.slug}/` }];

  // Get subcategories for this category
  const subcategories = DB.getSubcategoriesByCategory(category.id);
  childItems = subcategories
    .filter(sub => getAvailableLocalesForEntity(sub).includes(locale))
    .map(sub => {
      // Try to get hero image for the subcategory
      let image: ImageWithUrl | null = null;
      if (sub.heroImageId) {
        const img = loadImageById(sub.heroImageId);
        if (img) image = withAbsoluteUrl(img, siteBase);
      } else if (sub.ogImageId) {
        const img = loadImageById(sub.ogImageId);
        if (img) image = withAbsoluteUrl(img, siteBase);
      }

      return {
        title: getLocalizedField<string>(sub, 'title', locale) || sub.id,
        description: getLocalizedField<string>(sub, 'description', locale) || '',
        url: buildLocalizedUrl(locale, sub, base),
        image
      };
    });
} else {
  const subcategory = data as Subcategory;

  // Get breadcrumbs from database (localized)
  const crumbs = DB.getBreadcrumbs(subcategory);
  breadcrumbs = crumbs.map(crumb => {
    const entity = DB.getCategoryById(crumb.slug) || DB.getSubcategoryById(crumb.slug);
    const localizedTitle = entity
      ? getLocalizedField<string>(entity, 'title', locale) || (typeof crumb.title === 'string' ? crumb.title : '')
      : (typeof crumb.title === 'string' ? crumb.title : '');

    return {
      title: localizedTitle,
      url: `/${locale}/${crumb.path}/`
    };
  });

  // Get child subcategories
  const children = DB.getChildSubcategories(subcategory);
  childItems = children
    .filter(child => getAvailableLocalesForEntity(child).includes(locale))
    .map(child => {
      let image: ImageWithUrl | null = null;
      if (child.heroImageId) {
        const img = loadImageById(child.heroImageId);
        if (img) image = withAbsoluteUrl(img, siteBase);
      } else if (child.ogImageId) {
        const img = loadImageById(child.ogImageId);
        if (img) image = withAbsoluteUrl(img, siteBase);
      }

      return {
        title: getLocalizedField<string>(child, 'title', locale) || child.id,
        description: getLocalizedField<string>(child, 'description', locale) || '',
        url: buildLocalizedUrl(locale, child, base),
        image
      };
    });

  // Get related categories
  const relatedCategories = DB.getRelatedCategories(subcategory)
    .filter(cat => getAvailableLocalesForEntity(cat).includes(locale));

  relatedItems = relatedCategories.map(cat => {
    let image: ImageWithUrl | null = null;
    if (cat.heroImageId) {
      const img = loadImageById(cat.heroImageId);
      if (img) image = withAbsoluteUrl(img, siteBase);
    } else if (cat.ogImageId) {
      const img = loadImageById(cat.ogImageId);
      if (img) image = withAbsoluteUrl(img, siteBase);
    }

    return {
      title: getLocalizedField<string>(cat, 'title', locale) || cat.id,
      description: getLocalizedField<string>(cat, 'description', locale) || '',
      url: buildLocalizedUrl(locale, cat, base),
      image
    };
  });

  // Get parent category for image fallback
  parentCategory = DB.getCategoryById(subcategory.parentCategoryId);
}

// Resolve images with fallback chain
const ogImage = resolveOgImage(data, parentCategory, siteBase);
const heroImage = resolveHeroImage(data, siteBase);

// Build page context for internal linking
const linkContext: PageContext = {
  type,
  entity: data,
  id: data.id,
  slug: data.slug,
  locale
};

// Get localized content from database
const localizedContent = getLocalizedContentSection(data, locale);
const content = localizedContent || {};

// Overview content with SEO terminology for internal linking opportunities
const overviewItems: ContentItem[] = content.overview || [
  `This comprehensive guide covers everything you need to know about ${title.toLowerCase()}. Understanding this topic is essential for anyone working with programmatic SEO, whether you're building scalable content strategies or optimizing existing pages for search engines.`,
  `You'll learn how ${title.toLowerCase()} connects to broader concepts like keyword research, search intent analysis, and content architecture. We'll explore the relationship between technical implementation and content requirements, helping you build a solid foundation for your SEO strategy.`,
  `Whether you're focused on template design, internal linking, or structured data implementation, this resource provides the context you need to make informed decisions about your programmatic SEO approach.`
];

// Key Takeaways content (rendered as list)
// Title can be customized via content.keyTakeawaysTitle
const keyTakeawaysTitle = content.keyTakeawaysTitle || 'Key Takeaways';
const keyTakeaways: string[] = content.keyBenefits
  ? content.keyBenefits.filter((item): item is string => typeof item === 'string')
  : [
      `${title} is a core component of successful programmatic SEO`,
      'Connects to keyword research and search intent analysis',
      'Impacts template design and content architecture decisions',
      'Essential for building topical authority at scale'
    ];

// Why Choose content with SEO terminology for internal linking opportunities
const whyChooseItems: ContentItem[] = content.whyChoose || [
  `Understanding ${title.toLowerCase()} is crucial for building effective programmatic SEO campaigns. This knowledge helps you develop better content requirements, optimize your technical implementation, and create scalable page templates that rank well in search results.`,
  `By mastering ${title.toLowerCase()}, you'll improve your ability to conduct SERP analysis, build topical authority, and implement effective internal linking strategies. These skills are foundational for anyone serious about programmatic SEO success.`
];

// Build breadcrumb items for schema (including Home)
const homeBreadcrumb = { title: 'Home', url: `/${locale}/` };
const schemaBreadcrumbs = [homeBreadcrumb, ...breadcrumbs];

// Build current page URL for schemas
const currentPath = type === 'category'
  ? `/${locale}/${data.slug}/`
  : `/${locale}/${DB.getFullPath(data as Subcategory)}/`;

// Extract date fields for structured data
const datePublished = data.datePublished;
const dateModified = data.dateModified;

// Get localized rich results for structured data schemas
const richResults = getLocalizedRichResults(data.richResults, locale);

// Determine if page should be noindexed
const shouldNoindex = data.status === 'archived';
---

<BaseLayout
  title={title}
  description={description}
  ogImage={ogImage}
  locale={locale}
  hreflangLinks={hreflangLinks}
  alternateUrls={alternateUrls}
  noindex={shouldNoindex}
>
  <!-- Structured Data Schemas -->
  <BreadcrumbSchema items={schemaBreadcrumbs} siteBase={siteBase} />
  <WebPageSchema
    title={title}
    description={description}
    url={currentPath}
    siteBase={siteBase}
    breadcrumbs={schemaBreadcrumbs}
    locale={locale}
    datePublished={datePublished}
    dateModified={dateModified}
  />

  {richResults?.faq && richResults.faq.length > 0 && (
    <FAQPageSchema items={richResults.faq} />
  )}

  {richResults?.howTo && richResults.howTo.steps.length > 0 && (
    <HowToSchema
      name={richResults.howTo.name}
      description={richResults.howTo.description}
      steps={richResults.howTo.steps}
      totalTime={richResults.howTo.totalTime}
      estimatedCost={richResults.howTo.estimatedCost}
      supply={richResults.howTo.supply}
      tool={richResults.howTo.tool}
      image={richResults.howTo.image}
      siteBase={siteBase}
    />
  )}

  {richResults?.softwareApplication && (
    <SoftwareApplicationSchema
      name={richResults.softwareApplication.name}
      description={richResults.softwareApplication.description}
      applicationCategory={richResults.softwareApplication.applicationCategory}
      operatingSystem={richResults.softwareApplication.operatingSystem}
      offers={richResults.softwareApplication.offers}
      aggregateRating={richResults.softwareApplication.aggregateRating}
      screenshot={richResults.softwareApplication.screenshot}
      softwareVersion={richResults.softwareApplication.softwareVersion}
      datePublished={richResults.softwareApplication.datePublished}
      downloadUrl={richResults.softwareApplication.downloadUrl}
      installUrl={richResults.softwareApplication.installUrl}
      featureList={richResults.softwareApplication.featureList}
      requirements={richResults.softwareApplication.requirements}
      siteBase={siteBase}
    />
  )}

  {richResults?.aggregateRating && (
    <AggregateRatingSchema
      itemType={richResults.aggregateRating.itemType}
      itemName={richResults.aggregateRating.itemName}
      itemDescription={richResults.aggregateRating.itemDescription}
      itemUrl={richResults.aggregateRating.itemUrl}
      itemImage={richResults.aggregateRating.itemImage}
      ratingValue={richResults.aggregateRating.rating.ratingValue}
      ratingCount={richResults.aggregateRating.rating.ratingCount}
      reviewCount={richResults.aggregateRating.rating.reviewCount}
      bestRating={richResults.aggregateRating.rating.bestRating}
      worstRating={richResults.aggregateRating.rating.worstRating}
      siteBase={siteBase}
    />
  )}

  <!-- Hero Section -->
  {heroImage && <HeroImage image={heroImage} />}

  <!-- Breadcrumbs -->
  <nav class="breadcrumbs" aria-label="Breadcrumb">
    <ol class="breadcrumbs__list">
      <li class="breadcrumbs__item">
        <a href={`${base}/${locale}/`} class="breadcrumbs__link">Home</a>
        <span class="breadcrumbs__separator" aria-hidden="true">/</span>
      </li>
      {breadcrumbs.slice(0, -1).map((crumb) => (
        <li class="breadcrumbs__item">
          <a href={crumb.url} class="breadcrumbs__link">{crumb.title}</a>
          <span class="breadcrumbs__separator" aria-hidden="true">/</span>
        </li>
      ))}
      <li class="breadcrumbs__item">
        <span class="breadcrumbs__current" aria-current="page">
          {breadcrumbs[breadcrumbs.length - 1]?.title || title}
        </span>
      </li>
    </ol>
  </nav>

  <!-- Page Title -->
  <header class="page-header">
    <h1 class="page-header__title">{title}</h1>
    <p class="page-header__description">{description}</p>
  </header>

  <!-- Main Content -->
  <article class="content-body">
    <section>
      <h2>Overview</h2>
      <ContentRenderer items={overviewItems} linkContext={linkContext} />
    </section>

    <!-- Key Takeaways -->
    <aside class="takeaways">
      <h3 class="takeaways__title">{keyTakeawaysTitle}</h3>
      <ul class="takeaways__list">
        {keyTakeaways.map((item) => (
          <li class="takeaways__item">{item}</li>
        ))}
      </ul>
    </aside>

    <section>
      <h2>Why Choose {title}?</h2>
      <ContentRenderer items={whyChooseItems} linkContext={linkContext} />
    </section>
  </article>

  <!-- Child Categories Grid -->
  {childItems.length > 0 && (
    <section class="card-section">
      <header class="card-section__header">
        <h2 class="card-section__title">Explore {title} Topics</h2>
        <p class="card-section__description">
          Dive deeper into specific aspects of {title.toLowerCase()} with our detailed guides.
        </p>
      </header>
      <div class="card-grid">
        {childItems.map((item) => (
          <CategoryCard
            title={item.title}
            description={item.description}
            url={item.url}
            image={item.image}
          />
        ))}
      </div>
    </section>
  )}

  <!-- Related Categories Section -->
  {relatedItems.length > 0 && (
    <section class="card-section card-section--related">
      <div class="card-section__inner">
        <header class="card-section__header">
          <h2 class="card-section__title">Related Topics</h2>
          <p class="card-section__description">
            You might also be interested in these related categories.
          </p>
        </header>
        <div class="card-grid">
          {relatedItems.map((item) => (
            <CategoryCard
              title={item.title}
              description={item.description}
              url={item.url}
              image={item.image}
            />
          ))}
        </div>
      </div>
    </section>
  )}

  <!-- Back Navigation -->
  <div class="back-link">
    {breadcrumbs.length > 1 ? (
      <a href={breadcrumbs[breadcrumbs.length - 2].url}>
        ← Back to {breadcrumbs[breadcrumbs.length - 2].title}
      </a>
    ) : (
      <a href={`${base}/${locale}/`}>← Back to Home</a>
    )}
  </div>
</BaseLayout>
